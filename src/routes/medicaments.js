const express = require('express');
const mongoose = require('mongoose');
const router = express.Router();
const { User } = require('../models/User');
const { connectToPharmacyDB } = require('../config/database');
const { getPharmacyMedicaments } = require('../controllers/adminController');
const { authenticate } = require('../middlewares/auth');
const DrugImage = mongoose.connection.useDb('pharmacies').model('DrugImage', require('../models/DrugImage').schema);

const collectionExists = async (db, collectionName) => {
  try {
    const result = await db.collection(collectionName).findOne({}, { projection: { _id: 1 } });
    console.log(`üîç V√©rification collection ${collectionName} dans ${db.name}: ${result ? 'existe' : 'vide ou inexistante'}`);
    return !!result;
  } catch (error) {
    console.error(`‚ùå Erreur v√©rification collection ${collectionName} dans ${db.name}:`, error);
    return false;
  }
};

// Endpoint /list
router.get('/list', authenticate, async (req, res) => {
  try {
    const {
      minPrice,
      maxPrice,
      category,
      form,
      availableOnly,
      name,
      latitude,
      longitude,
      prescriptionOnly,
      sortByPrice // Ajout du param√®tre manquant
    } = req.query;

    console.log('üîç [listMedicaments] Requ√™te re√ßue:', req.query);

    const pharmacies = await User.find({
      role: 'pharmacie',
      isActive: true,
      'pharmacieInfo.baseMedicament': { $exists: true, $ne: null, $ne: '' }
    })
      .select('_id pharmacieInfo.nomPharmacie pharmacieInfo.adresseGoogleMaps pharmacieInfo.baseMedicament')
      .lean();

    console.log('üîç [listMedicaments] Pharmacies trouv√©es:', pharmacies.length);
    pharmacies.forEach(p => {
      console.log(`üè™ Pharmacie: ${p.pharmacieInfo?.nomPharmacie} - Base: ${p.pharmacieInfo?.baseMedicament}`);
    });

    if (!pharmacies.length) {
      console.log('‚ö†Ô∏è [listMedicaments] Aucune pharmacie trouv√©e');
      return res.status(404).json({ success: false, message: 'Aucune pharmacie trouv√©e' });
    }

    const query = {};
    if (minPrice) query.prix = { $gte: parseFloat(minPrice) };
    if (maxPrice) query.prix = { ...query.prix, $lte: parseFloat(maxPrice) };
    if (category) query.categorie = { $regex: category, $options: 'i' };
    if (form) query.forme = { $regex: form, $options: 'i' };
    if (availableOnly === 'true') query.quantite_stock = { $gt: 0 };
    if (prescriptionOnly !== undefined && prescriptionOnly !== '') query.est_sur_ordonnance = prescriptionOnly === 'true';
    if (name) {
      query.$or = [
        { nom: { $regex: name, $options: 'i' } },
        { nom_generique: { $regex: name, $options: 'i' } }
      ];
    }

    console.log('üîç [listMedicaments] Query MongoDB:', JSON.stringify(query, null, 2));

    // R√©cup√©rer tous les m√©dicaments et leurs noms uniques
    const allMedicaments = await Promise.all(
      pharmacies.map(async (pharmacy) => {
        try {
          // V√©rifier que la base existe et n'est pas undefined
          const baseName = pharmacy.pharmacieInfo?.baseMedicament;
          if (!baseName || baseName === 'undefined') {
            console.log(`‚ö†Ô∏è [listMedicaments] Base invalide pour ${pharmacy.pharmacieInfo?.nomPharmacie}: ${baseName}`);
            return [];
          }

          console.log(`üîç [listMedicaments] Connexion √† la base: ${baseName}`);
          const db = connectToPharmacyDB(baseName);
          const hasMedicamentsCollection = await collectionExists(db, 'medicaments');
          if (!hasMedicamentsCollection) {
            console.log(`‚ö†Ô∏è Aucune collection 'medicaments' dans ${baseName}`);
            return [];
          }

          const Medicament = db.model('Medicament', require('../models/Medicament').schema, 'medicaments');
          
          // Compter d'abord les documents qui correspondent
          const count = await Medicament.countDocuments(query);
          console.log(`üîç [listMedicaments] ${pharmacy.pharmacieInfo.nomPharmacie}: ${count} m√©dicaments trouv√©s avec la query`);

          if (count === 0) {
            return [];
          }

          const medicaments = await Medicament.find(query)
            .lean()
            .select('nom nom_generique prix quantite_stock est_sur_ordonnance categorie forme date_peremption dosage code_barre');

          console.log(`üîç [listMedicaments] ${pharmacy.pharmacieInfo.nomPharmacie}: r√©cup√©ration de ${medicaments.length} m√©dicaments`);

          return medicaments.map(med => ({
            ...med,
            pharmacyId: pharmacy._id,
            pharmacieInfo: {
              nomPharmacie: pharmacy.pharmacieInfo.nomPharmacie || pharmacy.nom,
              adresseGoogleMaps: pharmacy.pharmacieInfo.adresseGoogleMaps
            }
          }));
        } catch (error) {
          console.error(`‚ùå Erreur pour pharmacie ${pharmacy.pharmacieInfo?.nomPharmacie}:`, error);
          return [];
        }
      })
    );

    const allMeds = allMedicaments.flat();
    console.log(`üîç [listMedicaments] Total m√©dicaments avant images: ${allMeds.length}`);

    if (allMeds.length === 0) {
      console.log('‚ö†Ô∏è [listMedicaments] Aucun m√©dicament trouv√© avec les crit√®res sp√©cifi√©s');
      return res.json({ success: true, data: [] });
    }

    const uniqueNames = [...new Set(allMeds.map(med => med.nom.toLowerCase()))];
    console.log(`üîç [listMedicaments] Noms uniques pour images: ${uniqueNames.length}`);

    // R√©cup√©rer les images en une seule requ√™te
    const drugImages = await DrugImage.find({
      nom: { $in: uniqueNames }
    }).lean();

    console.log(`üîç [listMedicaments] Images trouv√©es: ${drugImages.length}`);

    const medsWithImages = allMeds.map(med => {
      const image = drugImages.find(img => 
        img.nom === med.nom.toLowerCase() || 
        (med.nom_generique && img.nom === med.nom_generique.toLowerCase())
      );
      return {
        ...med,
        images: image && image.images ? image.images : []
      };
    });

    let sortedMedicaments = medsWithImages;

    // Tri par prix (AJOUT DE LA LOGIQUE MANQUANTE)
    if (sortByPrice) {
      console.log(`üîç [listMedicaments] Tri par prix: ${sortByPrice}`);
      sortedMedicaments = sortedMedicaments.sort((a, b) => {
        if (sortByPrice === 'asc') {
          return parseFloat(a.prix) - parseFloat(b.prix);
        } else if (sortByPrice === 'desc') {
          return parseFloat(b.prix) - parseFloat(a.prix);
        }
        return 0;
      });
    }

    // Tri par proximit√©
    if (latitude && longitude && req.query.sortByProximity === 'true') {
      console.log(`üîç [listMedicaments] Tri par proximit√© activ√©`);
      
      const calculateDistance = (lat1, lon1, lat2, lon2) => {
        const R = 6371e3;
        const œÜ1 = (lat1 * Math.PI) / 180;
        const œÜ2 = (lat2 * Math.PI) / 180;
        const ŒîœÜ = ((lat2 - lat1) * Math.PI) / 180;
        const ŒîŒª = ((lon2 - lon1) * Math.PI) / 180;
        const a = Math.sin(ŒîœÜ / 2) * Math.sin(ŒîœÜ / 2) +
                  Math.cos(œÜ1) * Math.cos(œÜ2) * Math.sin(ŒîŒª / 2) * Math.sin(ŒîŒª / 2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        return R * c / 1000;
      };

      const getCoordinates = (adresse) => {
        if (!adresse) return null;
        const matchGoogle = adresse.match(/q=([-.\d]+),([-.\d]+)/);
        if (matchGoogle) return { latitude: parseFloat(matchGoogle[1]), longitude: parseFloat(matchGoogle[2]) };
        const matchEmbed = adresse.match(/!2d([-.\d]+)!3d([-.\d]+)/);
        if (matchEmbed) return { latitude: parseFloat(matchEmbed[2]), longitude: parseFloat(matchEmbed[1]) };
        return null;
      };

      sortedMedicaments = sortedMedicaments.sort((a, b) => {
        const coordA = getCoordinates(a.pharmacieInfo.adresseGoogleMaps);
        const coordB = getCoordinates(b.pharmacieInfo.adresseGoogleMaps);
        if (!coordA || !coordB) return 0;
        const distA = calculateDistance(parseFloat(latitude), parseFloat(longitude), coordA.latitude, coordA.longitude);
        const distB = calculateDistance(parseFloat(latitude), parseFloat(longitude), coordB.latitude, coordB.longitude);
        return distA - distB;
      });
    }

    console.log('‚úÖ [listMedicaments] M√©dicaments finaux:', sortedMedicaments.length);
    res.json({ success: true, data: sortedMedicaments });
  } catch (error) {
    console.error('‚ùå [listMedicaments] Erreur:', error);
    res.status(500).json({ success: false, message: 'Erreur serveur: ' + error.message });
  }
});

// Endpoint /filters - pour r√©cup√©rer les filtres disponibles
router.get('/filters', authenticate, async (req, res) => {
  try {
    console.log('üîç [getFilters] R√©cup√©ration des filtres...');

    const pharmacies = await User.find({
      role: 'pharmacie',
      isActive: true,
      'pharmacieInfo.baseMedicament': { $exists: true, $ne: null, $ne: '', $ne: 'undefined' }
    })
      .select('_id pharmacieInfo.baseMedicament pharmacieInfo.nomPharmacie')
      .lean();

    console.log('üîç [getFilters] Pharmacies trouv√©es:', pharmacies.length);
    pharmacies.forEach(p => {
      console.log(`üè™ Pharmacie: ${p.pharmacieInfo?.nomPharmacie} - Base: ${p.pharmacieInfo?.baseMedicament}`);
    });

    if (!pharmacies.length) {
      console.log('‚ö†Ô∏è [getFilters] Aucune pharmacie trouv√©e');
      return res.json({ success: true, data: { categories: [], forms: [] } });
    }

    const allCategories = new Set();
    const allForms = new Set();

    await Promise.all(
      pharmacies.map(async (pharmacy) => {
        try {
          // V√©rifier que la base existe et n'est pas undefined
          const baseName = pharmacy.pharmacieInfo?.baseMedicament;
          if (!baseName || baseName === 'undefined') {
            console.log(`‚ö†Ô∏è [getFilters] Base invalide pour ${pharmacy.pharmacieInfo?.nomPharmacie}: ${baseName}`);
            return;
          }

          console.log(`üîç [getFilters] Connexion √† la base: ${baseName}`);
          const db = connectToPharmacyDB(baseName);
          const hasMedicamentsCollection = await collectionExists(db, 'medicaments');
          if (!hasMedicamentsCollection) {
            console.log(`‚ö†Ô∏è [getFilters] Aucune collection 'medicaments' dans ${baseName}`);
            return;
          }

          const Medicament = db.model('Medicament', require('../models/Medicament').schema, 'medicaments');
          
          // R√©cup√©rer les cat√©gories distinctes
          const categories = await Medicament.distinct('categorie');
          categories.forEach(cat => {
            if (cat && cat.trim()) allCategories.add(cat.trim());
          });

          // R√©cup√©rer les formes distinctes
          const forms = await Medicament.distinct('forme');
          forms.forEach(form => {
            if (form && form.trim()) allForms.add(form.trim());
          });

        } catch (error) {
          console.error(`‚ùå [getFilters] Erreur pour pharmacie ${pharmacy.pharmacieInfo?.nomPharmacie}:`, error);
        }
      })
    );

    const result = {
      categories: Array.from(allCategories).sort(),
      forms: Array.from(allForms).sort()
    };

    console.log('‚úÖ [getFilters] Filtres r√©cup√©r√©s:', result);
    res.json({ success: true, data: result });
  } catch (error) {
    console.error('‚ùå [getFilters] Erreur:', error);
    res.status(500).json({ success: false, message: 'Erreur serveur' });
  }
});

// Endpoint /search
router.get('/search', async (req, res) => {
  try {
    const { nom, categorie, prixMax, page = 1, limit = 1000 } = req.query;
    const pageNum = parseInt(page);
    const limitNum = parseInt(limit);
    const skip = (pageNum - 1) * limitNum;

    console.log('üîç [searchMedicaments] Requ√™te:', { nom, categorie, prixMax, page, limit });

    const pharmacies = await User.find({ 
      role: 'pharmacie', 
      isActive: true, 
      'pharmacieInfo.baseMedicament': { $exists: true, $ne: null }
    }).lean();

    if (!pharmacies.length) {
      console.log('‚ö†Ô∏è [searchMedicaments] Aucune pharmacie trouv√©e');
      return res.status(200).json({
        success: true,
        data: { pharmacies: [], totalPages: 0, currentPage: pageNum, totalMedicaments: 0 }
      });
    }

    const query = {};
    if (nom) query.$or = [
      { nom: { $regex: nom, $options: 'i' } },
      { nom_generique: { $regex: nom, $options: 'i' } }
    ];
    if (categorie) query.categorie = { $regex: categorie, $options: 'i' };
    if (prixMax) query.prix = { $lte: Number(prixMax) };

    const results = await Promise.all(
      pharmacies.map(async (pharma) => {
        try {
          const db = connectToPharmacyDB(pharma.pharmacieInfo.baseMedicament);
          const hasMedicamentsCollection = await collectionExists(db, 'medicaments');
          if (!hasMedicamentsCollection) {
            console.log(`‚ö†Ô∏è [searchMedicaments] Aucune collection 'medicaments' dans ${pharma.pharmacieInfo.baseMedicament}`);
            return {
              pharmacie: {
                id: pharma._id,
                nom: pharma.pharmacieInfo.nomPharmacie || pharma.nom,
                base: pharma.pharmacieInfo.baseMedicament
              },
              medicaments: [],
              totalMedicaments: 0
            };
          }

          const Medicament = db.model('Medicament', require('../models/Medicament').schema, 'medicaments');
          const meds = await Medicament.find(query).limit(limitNum).skip(skip).lean();

          let drugImages = [];
          if (meds.length > 0) {
            try {
              const namesToSearch = [...new Set(
                meds.map(med => med.nom.toLowerCase()).concat(
                  meds.map(med => med.nom_generique?.toLowerCase()).filter(Boolean)
                )
              )];
              console.log(`üîç [searchMedicaments] Recherche images pour noms: ${namesToSearch.join(', ')}`);
              drugImages = await DrugImage.find({
                nom: { $in: namesToSearch }
              }).lean();
              console.log(`üîç [searchMedicaments] Images trouv√©es: ${drugImages.length}`);
            } catch (imageError) {
              console.error(`‚ùå [searchMedicaments] Erreur r√©cup√©ration images pour ${pharma.pharmacieInfo.nomPharmacie}:`, imageError);
              drugImages = [];
            }
          }

          const medicamentsWithImages = meds.map(med => {
            const image = drugImages.find(img => 
              img.nom === med.nom.toLowerCase() || 
              (med.nom_generique && img.nom === med.nom_generique.toLowerCase())
            );
            return {
              ...med,
              images: image && image.images ? image.images : []
            };
          });

          const total = await Medicament.countDocuments(query);
          return {
            pharmacie: {
              id: pharma._id,
              nom: pharma.pharmacieInfo.nomPharmacie || pharma.nom,
              base: pharma.pharmacieInfo.baseMedicament
            },
            medicaments: medicamentsWithImages,
            totalMedicaments: total
          };
        } catch (error) {
          console.error(`‚ùå [searchMedicaments] Erreur pour pharmacie ${pharma.pharmacieInfo.nomPharmacie}:`, error);
          return {
            pharmacie: {
              id: pharma._id,
              nom: pharma.pharmacieInfo.nomPharmacie || pharma.nom,
              base: pharma.pharmacieInfo.baseMedicament
            },
            medicaments: [],
            totalMedicaments: 0
          };
        }
      })
    );

    const totalGlobal = results.reduce((sum, result) => sum + result.totalMedicaments, 0);
    console.log('‚úÖ [searchMedicaments] Total global des m√©dicaments:', totalGlobal);

    res.json({
      success: true,
      data: {
        pharmacies: results,
        totalPages: Math.ceil(totalGlobal / limitNum),
        currentPage: pageNum,
        totalMedicaments: totalGlobal
      }
    });
  } catch (error) {
    console.error('‚ùå [searchMedicaments] Erreur:', error);
    res.status(500).json({ success: false, message: 'Erreur serveur' });
  }
});

// Endpoint /pharmacy/:pharmacyId/medicaments
router.get('/pharmacy/:pharmacyId/medicaments', authenticate, getPharmacyMedicaments);

// Endpoint /test/:base
router.get('/test/:base', async (req, res) => {
  try {
    const { base } = req.params;
    console.log(`üîç [testBase] Test connexion √† la base: ${base}`);
    const db = connectToPharmacyDB(base);
    
    const hasMedicamentsCollection = await collectionExists(db, 'medicaments');
    if (!hasMedicamentsCollection) {
      return res.status(404).json({ success: false, message: `Aucune collection 'medicaments' dans ${base}` });
    }

    const Medicament = db.model('Medicament', require('../models/Medicament').schema, 'medicaments');
    
    console.log(`üîç [testBase] Ex√©cution find dans ${base}`);
    const meds = await Medicament.find({}).limit(5).lean();
    console.log(`üîç [testBase] M√©dicaments trouv√©s dans ${base}:`, meds.length);
    
    const total = await Medicament.countDocuments({});
    console.log(`üîç [testBase] Total documents dans ${base}:`, total);
    
    res.json({
      success: true,
      data: {
        medicaments: meds,
        totalMedicaments: total
      }
    });
  } catch (error) {
    console.error(`‚ùå [testBase] Erreur test base ${req.params.base}:`, error);
    res.status(500).json({ success: false, message: 'Erreur serveur' });
  }
});

module.exports = router;